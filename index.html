<!DOCTYPE html>
<html>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>

    body {
      margin:0;
      padding:0;
      font-family: "Helvetica Neue", "Segoe UI", -apple-system, BlinkMacSystemFont, Roboto, Oxygen, Ubuntu, Cantarell, "Fira Sans", "Droid Sans", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
      background-color:white;
    }

    .plot {
      width: 100%;
      height: 100%;
    }

    .top-container {
      background-color: #f1f1f1;
      padding: 30px;
      margin: 0%;
    }

    .header {
      padding: 10px 16px;
      background: rgb(0, 0, 0);
      text-align: center;
      color: #f1f1f1;
      border:0%
    }

    .content {
      padding: 16px;
      margin: 15%;
      margin-top: 0%;
    }

    .sticky {
      position: fixed;
      top: 0;
      width: 100%;
    }

    .sticky + .content {
      padding-top: 102px;
      margin: 15%;
      margin-top: 0%;
    }

    /* Three image containers (use 25% for four, and 50% for two, etc) */
    .column {
    float: left;
    width: 33.33%;
    padding: 5px;
    margin-left: 8%;
    }

    /* Clear floats after image containers */
    .row::after {
    content: "";
    clear: both;
    display: table;
    }

    img{
    display: block;
    margin-left: auto;
    margin-right: auto;
    }

    #timeline {
      font-family: Arial, Helvetica, sans-serif;
      border-collapse: collapse;
      width: 100%;
    }

    #timeline td, #timeline th {
      border: 1px solid #ddd;
      padding: 8px;
    }

    #timeline tr:nth-child(even){background-color: #f2f2f2;}

    #timeline tr:hover {background-color: #ddd;}

    #timeline th {
      padding-top: 12px;
      padding-bottom: 12px;
      text-align: left;
      background-color:black;
      color: white;
    }
    </style>
    <meta name="viewport" content="width=device-width, initial-scale=1">
       <link rel="stylesheet" href="https://combinatronics.com/SaswatD27/21cs460_group01/main/katex/katex.min.css">

   <link rel="stylesheet" href="https://combinatronics.com/SaswatD27/21cs460_group01/main/katex/github.min.css">
</head>
<div>
<div class="container">&nbsp;</div>
</div>
<div>
<div class="container" style="padding-left: 80px;">&nbsp;</div>
</div>
<div>
<div>
<div>
<div>
<div>
<div>
<div class="container"><header>
<h1 style="text-align: center;">Course Project, CS460, Fall 2021-22</h1>
<h2 style="text-align: center;">On Federated Learning and Possible Improvements</h2>
</header>
<p style="text-align: center;">Saswat Das <br />1811138 | saswat.das@niser.ac.in | School of Mathematical Sciences, NISER, HBNI <br />Suraj Ku. Patel<br />1811163 | suraj.kpatel@niser.ac.in | School of Physical Sciences, NISER, HBNI <br /><br /><a href="https://github.com/SaswatD27/CS460-ML-Project-2021">Project Github Repository</a></p>
<hr />
<h3>1. Project Proposal (6 Sept 2021)</h3>
<h4>Introduction</h4>
<img style="display: block; margin-left: auto; margin-right: auto;" src="https://blog.ml.cmu.edu/wp-content/uploads/2019/11/Screen-Shot-2019-11-12-at-10.41.38-AM-970x377.png" alt="Federated Learning Schematic" width="500" />
<p>&nbsp;</p>
<p><em>Federated learning</em> (abbreviated as <em>FL</em>) refers to the practice of conducting machine learning based on several users' data by having each user, given an initial global model by a central server, <em>locally train&nbsp;</em>a model on their local devices, then communicate their locally trained model to the central server, following which each user's local model is&nbsp;<em>aggregated&nbsp;</em>at the central server with that of others, and used to update the global model.</p>
<p>This is in contrast to centralised learning, where the users' data would have been sent to the central server, and a model would have been trained on all that collected data in one central server.</p>
<h5>Advantages?</h5>
<p>Quite some!</p>
<ol>
<li>The user's personal data never leaves their local device, thus ensuring a healthy measure of privacy;</li>
<li>Can possibly incorporate nuances of each user's local model by a suitable aggregation technique/algorithm to provide better, more nuanced learning.</li>
</ol>
<h5>Concerns/Areas of Possible Improvement</h5>
<ul>
<li>Communication costs post local training and optimising number of communication rounds between each local device and the central server:</li>
<li>Cost of computation due to local training on each device and effects on user experience during local training;</li>
<li>Possible improvements in aggregation algorithms;</li>
<li>Enhancement of privacy, and making sure no adversary can conclude from the (say, weights of the) local models an individual user's personal information or behaviour.</li>
</ul>
<h4>What we intend to do - a brief sketch</h4>
<ul>
<li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">Implement a Federated Learning algorithm (tentatively  <span style="font-weight: 400;">FederatedAveraging <span style="font-weight: 400;">) after locally training models using algorithms like SGD (as suggested) on generated datasets, or even implementing some neural network(s) if possible using popular datasets (viz. FEMNIST, Shakespeare, Sentiment140, CIFAR 10) if we are feeling bold. We can use TensorFlow and SherpaAI for this if possible/needed (no promises). </li>
<li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">Using the (local) learning algorithm as a baseline, we can compare the results of our FL based trained-and-aggregated model with centralised learning with the same algorithm, and some other popular algorithms. </li>
<li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;"><span style="font-weight: 400;">Suggest improvements to the paradigm just implemented in terms of
<ol>
<li>The aggregating formula/algorithm;</li>
<li>minimising rounds of communication and computational cost per local device; and/or</li>
<li>enhancing privacy (viz. by adding differential privacy into the mix).</li>
</ol>
</li>
</ul>
<p><span style="font-weight: 400;">Then we will see how said tweaks work in terms of these metrics and report any observed improvements/changes (fingers crossed). </p>
<h4>Midway Targets</h4>
<ul>
<li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">Successfully implement an FL model, and come up with some preliminary results; </li>
<li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">Suggest some tweaks and improvements to test out; </li>
<li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">If needed, present pertinent concepts from relevant literature. </li>
</ul>
<h4>Work Division</h4>
<ol>
<li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">Coding/Privacy based considerations - Joint task, will divide up coding of different components fluidly as needed. </li>
<li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">Data analysis and visualisation - Suraj </li>
<li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">Mathematics, formulae, proofs - Saswat </li>
<li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">Report writing and project website maintenance - Joint task </li>
</ol>
<h4>Expected Results</h4>
<ul>
<li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">Performance of FL based learning: almost as sound as if the learning was centralised, and maybe more nuanced. </li>
<li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">Either of these: Increased privacy, less communication rounds with the server, less/quicker local device computation, better aggregation. </li>
</ul>
<h4>Relevant Papers</h4>
<ul>
<li aria-level="1">McMahan, H. B. et al. &ldquo;Communication-Efficient Learning of Deep Networks from Decentralized Data.&rdquo; AISTATS (2017).</li>
<li aria-level="1">Konecn&yacute;, Jakub et al. &ldquo;Federated Learning: Strategies for Improving Communication Efficiency.&rdquo; ArXiv abs/1610.05492 (2016): n. pag.</li>
<li>Barroso, Nuria Rodr&iacute;guez et al. &ldquo;Federated Learning and Differential Privacy: Software tools analysis, the Sherpa.ai FL framework and methodological guidelines for preserving data privacy.&rdquo; Inf. Fusion 64 (2020): 270-292.</li>
</ul>
<hr />
<h4>Project Presentation Slides</h4>
<embed style="background-image: url('img/object.gif'); display: block; margin-left: auto; margin-right: auto;" src="https://drive.google.com/viewerng/viewer?embedded=true&amp;url=https://github.com/SaswatD27/CS460-ML-Project-2021/raw/main/CS460%20-%20Project%20Proposal.pdf" width="500" height="375"></embed><hr /></div>
</div>
</div>
</div>
</div>
</div>
</div>
<div>
<div>
<div>
<div>
<div>
<h3>2. Project Midway</h3>
</div>
</div>
</div>
</div>
</div>
<div>
<div>
<div>
<div>
<div>
<h4>Literature Review</h4>
</div>
</div>
</div>
</div>
</div>
<div>
<div>
<div>
<div>
<div>
<p>Some of the most important papers we referred to are listed below.</p>
</div>
</div>
</div>
</div>
</div>
<div>
<div>
<div>
<div>
<div>
<ul>
<li>McMahan, H. Brendan et al. &ldquo;Communication-Efficient Learning of Deep Networks from Decentralized Data.&rdquo;&nbsp;<em>AISTATS</em>&nbsp;(2017).</li>
<li>Konecn&yacute;, Jakub et al. &ldquo;Federated Learning: Strategies for Improving Communication Efficiency.&rdquo;&nbsp;<em>ArXiv</em> abs/1610.05492 (2016).</li>
<li>Wei, Kang et al. &ldquo;Federated Learning With Differential Privacy: Algorithms and Performance Analysis.&rdquo;&nbsp;<em>IEEE Transactions on Information Forensics and Security</em>&nbsp;15 (2020): 3454-3469.</li>
<li>Ji, Shaoxiong et al. &ldquo;Dynamic Sampling and Selective Masking for Communication-Efficient Federated Learning.&rdquo;&nbsp;<em>ArXiv</em> abs/2003.09603 (2020).</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div>
<div>
<div>
<div>
<div>
<ol>
<li><strong>McMahan et al</strong>
<ul>
<li>
<p>Introduces federated learning;</p>
</li>
<li>
<p>Addresses issues such as unbalanced volume of datapoints across all clients, limited communication capabilities of clients (via multiple rounds of communication), and the mass distributed nature of the clients, and the non-IID nature of data as an individual&rsquo;s data is specific;</p>
</li>
<li>
<p>Introduces <code>FedAvg</code> ( \(w_{t+1}\gets\sum_{i=1}^K\frac{n_k}{n}w_{t+1}^k\) );</p>
</li>
<li>
<p>Talks about controlling parallelism of local computation and increased local computation by varying batch size for gradient descent (decreasing it increases amount/precision of computation, no. of rounds, and no. of clients queried per round (affects parallelism).</p>
</li>
<li><strong>Remarks:&nbsp;</strong>
<ul>
<li>This provides us with a robust federated learning paradigm, but of course, as we shall soon see, this is a naive approach in terms of privacy, as there have supposedly been attacks in which adversaries have used weight updates in this scheme, say from a facial recognition application, to compromise the identities of users;</li>
<li>Also this may seem pretty intuitive (and as we shall see, this works pretty well for SGD), it is sort of a simple arithmetic mean at the end of the day, and might be unable to capture some subtle nuances of the weight vectors received from clients, maybe some non linear aggregation formula could work better in certain contexts, and it is a good area to look into.</li>
<li>The idea behind increasing parallelism by lowering the number of rounds of communication and increasing computation in between rounds locally by making the task at hand more precise (viz. by reducing batch size for gradient descent) is fairly intuitive, but is there a way to have clients with slower connections begin to upload their weight vectors for a certain (scheduled) round of communication prior to others with no such constraint? If so, how should rounds be scheduled?</li>
</ul>
</li>
</ul>
</li>
<li><strong>Wei et al</strong>
<ul>
<li>
<p>Introduces Gaussian noise w.r.t. a clipping parameter  \(C\)  to weight vector uploads, weights scaled w.r.t.  \(C\) ;</p>
</li>
<li>
<p>Motivation: Na&iuml;vely uploaded weights carry the risk of being used by adversaries to compromise users;</p>
</li>
<li>
<p>Proposes uplink and optional downlink noise addition;</p>
</li>
<li>
<p>Takes fairly large values for the privacy budget;</p>
</li>
<li>
<p>Accuracy improves with no. of clients queried and rounds of communication;</p>
</li>
<li>
<p>Best accuracy when clients have (near) identical amounts of quality data;</p>
</li>
<li>
<p>Akin to central differential privacy, straightforward noise addition.</p>
</li>
<li><strong>Remarks:</strong>
<ul>
<li>This is a fairly straightforward method of adding Gaussian noise (and ergo endow approximate differential privacy) into the weight uploads. But are there better ways of doing the same? We briefly considered implementing something similar using the exponential mechanism, and given how versatile it is, it could perhaps capture the nuances of the local training better, especially if you consider that out-of-bound (w.r.t. the clipping threshold) weight vectors are simply scaled down w.r.t. the clipping threshold (for good reason), can this be made more dynamic and inclusive of the factors and nuances in each client's dataset/model? It is an interesting thought.</li>
<li>We also noticed that the authors do not mention a norm per se in the paper for the weight vectors while defining their algorithm (though there are some obvious choices, this was a bit unsettling).</li>
<li>The authors use large values of the privacy budget (given the number of clients/the massively distributed nature of the client pool, this seems fair); can this be reduced while not having a major increase in error? Or with the minimum possible increase in the number of required clients to counteract any increase in noise?</li>
</ul>
</li>
</ul>
</li>
<li><strong>Konečn&yacute; et al</strong>
<ul>
<li>
<p>Introduces methods to reduce the uplink communication costs by reducing the size of the updated model sent back by the client to the server.</p>
</li>
<li>
<p>Motivation: Poor bandwidth/expensive connections of a number of the participating devices (clients) leads to problems during the aggregation of data for FL.</p>
</li>
<li>
<p>Two methods for sending a smaller model are:</p>
<ul>
<li>
<p><em>Structured updates</em>, updates are from a restricted space and can be parametrized using a smaller number of variables. Algorithms: Low Rank and Random Mask.</p>
</li>
<li>
<p><em>Sketched updates</em>, full model updates are learned but a compressed model update is sent to the server. Algorithms: Subsampling, Probabilistic quantization, and structured random rotations.</p>
</li>
</ul>
</li>
<li>
<p><code>FedAvg</code> is used for the experiments to decrease the number of rounds of communication required to train a good model.</p>
</li>
<li>
<p>Conclusions of the paper</p>
<ul>
<li>
<p>Random mask performs significantly better than low rank, as the size of the updates is reduced.</p>
</li>
<li>
<p>Random masking gives higher accuracy as compared to sketched updates method but reaches moderate accuracy much slower.</p>
</li>
<li>
<p>Quantization algorithm alone is very unstable For a small number of quantization bits and smaller modes, and random rotation with quantization is more stable and has improved performance as compared to without rotation.</p>
</li>
<li>
<p>By increasing the number of rounds of training, the fraction of clients taken per round can be minimised without risking accuracy.</p>
</li>
<li>
<p>Introduced an important and practical tradeoff in the FL: one can select more clients in each round while having each of them communicate less, and obtain the same accuracy as using fewer clients, but having each of them communicate more.</p>
</li>
<li>Note (The random mask's indices/low rank's encoding matrix can be elegantly encoded in a random seed, we haven't implemented it that way per se, though the idea is the same, but that is a fairly elegant manner of going about it, not to mention the significant advantage of terms of just having to remember a seed and not an array of indices/a matrix.)</li>
</ul>
</li>
</ul>
</li>
<li>Extra:<strong> Ji et al</strong>
<ul>
<li>Proposes dynamic sampling and selective mask;</li>
<li>Dynamic sampling: In contrast to the usual way of sampling clients during each round of communication (i.e. static sampling), we define a decay constant, called  \(\beta\), and if the initial sampling rate is  \(C\) , then we choose  \(\frac{C}{\exp(\beta t)}\)  fraction of clients for round  \(t\)  (starting with  \(t=0\) ) ;</li>
<li>Selective mask: Instead of fully (uniformly) randomised selection of indices for a mask, choose the top  \(k\)  indices with the most significant updates to the initial model for each client;</li>
<li>Selective mask consistently outperformed random mask in terms of accuracy and rate of convergence;</li>
<li>Dynamic sampling gave accuracy comparable to static sampling, but at a significant loss in communication cost.</li>
<li><strong>Remarks:</strong>
<ul>
<li>We have a few bones to pick here: while these work extremely well all things considered, would not it be better if dynamic sampling chose to sample a larger number of clients in response to an increase in observed error after a particular vis-a-vis previous rounds to help decrease the error for subsequent rounds? This could be a neat feature.</li>
<li>Selective sampling chooses a specified number of the most significant (by magnitude) updates, and it definitely seems to be working really well, but we are concerned if in the process, i.e. by disregarding the others, we might be losing some important nuance in the process (i.e. this reasoning seems to be kind of reductionist and black-and-white). So can we instead choose mostly from among the top updates, and reserve a small proportion for those not in that club, so to speak? And if so, will this approach yield any advantages? Might as well try that out.&nbsp;</li>
</ul>
</li>
</ul>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div>
<div>
<div>
<div>
<div>
<h4>Techniques Used/Explored</h4>
</div>
</div>
</div>
</div>
</div>
<div>
<div>
<div>
<div>
<div>
<ul>
<li>
<p>For aggregation, we used <code>FedAvg </code>for the most vanilla FL implementation, and then added to it as necessary for the implementation of more sophisticated FL techniques;</p>
</li>
<li>
<p>The Gaussian Mechanism to provide  \((\varepsilon,\)\) -differential privacy pre-upload from each device (Noising before Aggregation), as introduced by Wei et al.;</p>
</li>
<li>
<p><em>Static Sampling</em> of clients for every round of training to reduce communication rounds per user;</p>
</li>
<li>
<p><em>Random Mask</em> and <em>Probabilistic Quantisation</em> as described by Konečn&yacute; et al;</p>
</li>
<li>
<p><em>Dynamic Sampling</em> of clients to successively reduce the proportion of clients involved in successive rounds of communication to further save on rounds of communication and computational resources (as proposed by Ji et al);</p>
</li>
<li>
<p>Considering/considered using: <em>Selective Mask</em>&nbsp;(especially when working with larger weight vectors/matrices).</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div>
<div>
<div>
<div>
<div>
<h4>Experiments and Observations</h4>
</div>
</div>
</div>
</div>
</div>
<div>
<div>
<div>
<div>
<div>
<p>We implemented <code>FedAvg</code> from scratch in Python, with a 0.25 static sampling rate, with anywhere between 3 to 5 (or more) rounds of calling for training from sampled (w.r.t. the uniform distribution) clients, with local training involving multiple linear regression implemented via Stochastic Gradient Descent on a synthetically generated dataset for about 500 clients, with static subsampling (contrast with dynamic subsampling).</p>
</div>
</div>
</div>
</div>
</div>
<div>
<div>
<div>
<div>
<div>
<p>The generated datasets, generated around a pre-chosen/generated "true weights vector" (we chose the dimension of these weight vectors to be 7) (e.g.  \([1, 2, 4, 3, 5, 6, 1.2]\) ), are mostly IID as we focused more on implementing a model atop that.</p>
</div>
</div>
</div>
</div>
</div>
<div>
<div>
<div>
<div>
<div>
<p>As we are using regression here, we use, for a particular instance, average training/testing error per data point as a metric of a deployment&rsquo;s accuracy, and simply measure the time taken by running it on Google Colab and compare them as a rough measure of how quick each is, and implement centralised learning to serve as a baseline for our exploration of these FL paradigms.</p>
</div>
</div>
</div>
</div>
</div>
<div>
<div>
<div>
<div>
<div>
<p>We then tried the above listed techniques, sometimes standalone or in conjunction with each other as follows.</p>
</div>
</div>
</div>
</div>
</div>
<div>
<div>
<div>
<div>
<div>
<ol>
<li><strong>Centralised Learning (As a Baseline)</strong><br />
<p>For centralised learning, we simply gathered and flattened the list of all local datasets into a cumulative list of all datapoints, and ran SGD on it for 100 epochs.<br />Time Taken  \(\approx 268-270\)  seconds.<br />Average Training Error for Centralised Learning on SGD  \(\approx 3.2472\times 10^{-29}\). <br />Average Testing Error for Centralised Learning on SGD  \(\approx 3.2154 \times 10^{-29}\). </p>
</li>
<li><strong>Vanilla <code>FederatedAveraging/FedAvg</code></strong>
<p>We then ran vanilla <code>FedAvg</code> with static sampling of clients at a rate of 0.25 of the client population per round of training on the above mentioned local datasets, with 100 epochs per round of local training. Number of rounds,  \(T=5\) .<br />Time taken  \(\approx 362\)  seconds.<br />Average Training Error for Vanilla FedAvg on SGD  \(\approx 2.5331\times 10^{-18}\) .<br />Average Testing Error for Vanilla FedAvg on SGD  \(\approx 2.6021\times 10^{-18}\) .</p>
<ol>
<li><strong>Noising before Aggregation (From Wei et al)</strong>
<p>Adds Gaussian noise to appropriately clipped weights from each user. Motivation: To stop attacks involving reconstruction of raw data/private information from na&iuml;ve uploading of weight vectors/matrices. Optionally adds downlink DP, but we felt it was unnecessary.</p>
<p>We ran <code>FedAvg</code> with static sampling of clients at a rate of 0.25 per round of training, clipping the locally generated weight vectors to gain bounds (defining upper bound of the norm of a weight vector as  \(C =1.01\times\max(w_i)\) , where  \(w -\)  weight vector, for the sake of computing the sensitivity of queries for the weight vectors, then adding Gaussian noise calibrated to  \(C,\varepsilon,\delta\)  to each weight ( \(\varepsilon=70,\delta=0.1\) ) with 100 epochs per round of local training. Number of rounds,  \(T=5\) .<br />Time taken  \(\approx 349\)  seconds (which makes it about as fast as vanilla <code>FedAvg</code>).<br />Average Training Error for NbA FedAvg on SGD  \(\approx 7.2562\times 10^{-7}\) .<br />Average Testing Error for NbA FedAvg on SGD  \(\approx 6.6740\times10^{-7}\) .</p>
</li>
</ol>
</li>
<li><strong>NbAFL with Random Mask</strong>
<p>We use the same setup as for the above NbAFL implementation, but with a layer of uniformly chosen random masks, excluding  \(\approx s=0.25\)  of the weights, prior to uploading by a client. Seems to consistently outperform base NbAFL in terms of accuracy, also reduces communication overhead!<br />Time taken  \(\approx 356\)  seconds.<br />Average Training Error  \(\approx 0.006601\). <br />Average Testing Error  \(\approx 0.007577\). </p>
</li>
<li><strong>NbAFL with Probabilistic Binarisation</strong>
<p>We again use the same setup and parameters as our vanilla NbAFL implementation, but with probabilistic binarisation implemented atop it.<br />Time taken  \(\approx 356\)  seconds.<br />Average Training Error  \(\approx 0.021241\) .<br />Average Testing Error  \(\approx 0.019635\) </p>
</li>
<li><strong>NbAFL with Dynamic Sampling</strong>
<p>We again adopt the same setup as that for our vanilla NbAFL implementation, but instead of static sampling of clients, we sample clients with an initial rate of  \(0.25\) , which decays by a factor of  \(\frac 1{\exp(\beta t)}\) , where  \(t =\)  number of rounds elapsed. We take  \(\beta=0.05\) .<br />Time taken  \(\approx 334\)  seconds.<br />(Saves on time and no. of communication rounds!)<br />Average Training Error  \(\approx 0.010684\) .<br />Average Testing Error  \(\approx 0.010908\) .</p>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div>
<div>
<div>
<div>
<div>
<p>The following table summarises the parameters used for and the results of our experiments (to be fair, we had to fiddle with a fair of different values for parameters and variations in algorithms to fix these for now)</p>
</div>
</div>
</div>
</div>
</div>
<div>
<div>
<div>
<div>
<div>
<div id="tab:my-table">
<table style="margin-left: auto; margin-right: auto; height: 353px;"><caption>Local Learning Rate, \(\alpha = 0.01\) ; No. of local iterations for SGD \(=100\) , No. of clients \(=500\)</caption>
<thead>
<tr class="header" style="height: 53px;">
<th style="height: 53px; width: 78.6806px;">Name of Model</th>
<th style="height: 53px; width: 9.55556px;">T</th>
<th style="height: 53px; width: 73.2361px;">Client Sampling Rate</th>
<th style="height: 53px; width: 116.486px;">\(\varepsilon\)</th>
<th style="height: 53px; width: 74.125px;">\(\delta\)</th>
<th style="height: 53px; width: 100.931px;">Training Error</th>
<th style="height: 53px; width: 175.931px;">Testing Error</th>
<th style="height: 53px; width: 47.5694px;">Time Taken (sec)</th>
<th style="height: 53px; width: 99.6806px;">Other Parameters</th>
</tr>
</thead>
<tbody>
<tr class="odd" style="height: 53px;">
<td style="height: 53px; width: 78.6806px;">Centralised SGD</td>
<td style="height: 53px; width: 9.55556px;">-</td>
<td style="height: 53px; width: 73.2361px;">-</td>
<td style="height: 53px; width: 116.486px;">-</td>
<td style="height: 53px; width: 74.125px;">-</td>
<td style="height: 53px; width: 100.931px;">\(3.2472\times 10^{-29}\)</td>
<td style="height: 53px; width: 175.931px;">\(3.2154 \times 10^{-29}\)</td>
<td style="height: 53px; width: 47.5694px;">268 - 270</td>
<td style="height: 53px; width: 99.6806px;">-</td>
</tr>
<tr class="even" style="height: 53px;">
<td style="height: 53px; width: 78.6806px;">Vanilla <code>FedAvg</code></td>
<td style="height: 53px; width: 9.55556px;">5</td>
<td style="height: 53px; width: 73.2361px;">0.25</td>
<td style="height: 53px; width: 116.486px;">-</td>
<td style="height: 53px; width: 74.125px;">-</td>
<td style="height: 53px; width: 100.931px;">\(2.5331\times 10^{-18}\)</td>
<td style="height: 53px; width: 175.931px;">\(2.6021\times 10^{-18}\)</td>
<td style="height: 53px; width: 47.5694px;">362</td>
<td style="height: 53px; width: 99.6806px;">-</td>
</tr>
<tr class="odd" style="height: 53px;">
<td style="height: 53px; width: 78.6806px;">NbAFL</td>
<td style="height: 53px; width: 9.55556px;">5</td>
<td style="height: 53px; width: 73.2361px;">0.25</td>
<td style="height: 53px; width: 116.486px;">70</td>
<td style="height: 53px; width: 74.125px;">0.01</td>
<td style="height: 53px; width: 100.931px;">\(7.2562\times 10^{-7}\)</td>
<td style="height: 53px; width: 175.931px;">\(6.6740\times10^{-7}\)</td>
<td style="height: 53px; width: 47.5694px;">349</td>
<td style="height: 53px; width: 99.6806px;">-</td>
</tr>
<tr class="even" style="height: 53px;">
<td style="height: 53px; width: 78.6806px;">NbAFL w/ Random Mask</td>
<td style="height: 53px; width: 9.55556px;">5</td>
<td style="height: 53px; width: 73.2361px;">0.25</td>
<td style="height: 53px; width: 116.486px;">70</td>
<td style="height: 53px; width: 74.125px;">0.01</td>
<td style="height: 53px; width: 100.931px;">0.006601</td>
<td style="height: 53px; width: 175.931px;">0.007577</td>
<td style="height: 53px; width: 47.5694px;">356</td>
<td style="height: 53px; width: 99.6806px;">\(s=0.25\)</td>
</tr>
<tr class="odd" style="height: 35px;">
<td style="height: 35px; width: 78.6806px;">NbAFL w/ Prob. Bin.</td>
<td style="height: 35px; width: 9.55556px;">5</td>
<td style="height: 35px; width: 73.2361px;">0.25</td>
<td style="height: 35px; width: 116.486px;">70</td>
<td style="height: 35px; width: 74.125px;">0.01</td>
<td style="height: 35px; width: 100.931px;">0.021241</td>
<td style="height: 35px; width: 175.931px;">0.019635</td>
<td style="height: 35px; width: 47.5694px;">356</td>
<td style="height: 35px; width: 99.6806px;">-</td>
</tr>
<tr class="even" style="height: 53px;">
<td style="height: 53px; width: 78.6806px;">NbAFL w/ Dyn. Samp.</td>
<td style="height: 53px; width: 9.55556px;">5</td>
<td style="height: 53px; width: 73.2361px;">0.25</td>
<td style="height: 53px; width: 116.486px;">70</td>
<td style="height: 53px; width: 74.125px;">0.01</td>
<td style="height: 53px; width: 100.931px;">0.010684</td>
<td style="height: 53px; width: 175.931px;">0.010908</td>
<td style="height: 53px; width: 47.5694px;">334</td>
<td style="height: 53px; width: 99.6806px;">\(\beta=0.05\)</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
<div>
<div>
<div>
<div>
<div>
<p>Note that the errors happen to be quite small compared to the weight vectors' magnitude, with a maximum being in the neighbourhood of 1% error to "true" weight vector (norm/coordinates) ratio, roughly.</p>
</div>
</div>
</div>
</div>
</div>
<div>
<div>
<div>
<div>
<div>
<h4>Suggested Tweaks and Possible Improvements to Try Out to Extend the Baselines</h4>
</div>
</div>
</div>
</div>
</div>
<div>
<div>
<div>
<div>
<div>
<ul>
<li>
<p>Silo-ing users with similar characteristics and running a separate FL paradigm within these silos;</p>
</li>
<li>
<p>Applications to dapps (decentralised applications) on P2P networks (given that uploaded weight vectors are more or less public and aggregation does not take much time);</p>
</li>
<li>
<p>Trying other mechanisms (viz. exponential) out on NbAFL for possible improvement, or explore locally differentially private techniques instead (some baseline work on this exists);</p>
</li>
<li>
<p>Trying Selective Mask from out, and slightly diffusing the choice from the top  \(k\)  updates to some of the lower updates;</p>
</li>
<li>
<p>Making dynamic sample more dynamic and efficient by calibrating decay w.r.t. error per round of communication (more error \(\implies\) less decay;</p>
</li>
<li>
<p>Exploring mutual benefits of probabilistic quantisation and noise addition, calibrating no. of quanta to the magnitude of the noise;</p>
</li>
<li>
<p>Looking at tweaks to <code>FedAvg</code> in certain contexts;</p>
</li>
<li>Think of how to further unlink clients from their uploaded weights (perhaps mixes will help);</li>
<li>
<p>Anything else that strikes our minds.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div>
<div>
<div>
<div>
<div>
<p>We may tentatively try implementing the above FL models for more complex local training algorithms (viz. ConvNets using FEMNIST), but this is secondary/optional.</p>
</div>
</div>
</div>
</div>
</div>
<div>
<div>
<div>
<div><hr /></div>
</div>
</div>
</div>
<div>
<div>
<div>
<div>
<p>Here is the <a href="https://github.com/SaswatD27/21cs460_group01/blob/main/Code/CS460_FL_1_01.ipynb">link</a> to the .ipynb file containing the older version of our code (updated last on 17 Oct '21).</p>
</div>
</div>
</div>
</div>
<div>
<div>
<div>
<div>
<div><hr /></div>
</div>
</div>
</div>
</div>
<div>
<div>
<div>
<div>
<div>
<h4>Midway Presentation Slides</h4>
(Kindly Exclude The Title and Bibliography Slides from the Slide Count)</div>
</div>
</div>
</div>
</div>
<div>
<div>
<div>
<div>
<div>
<p><embed style="background-image: url('img/object.gif'); display: block; margin-left: auto; margin-right: auto;" src="https://drive.google.com/viewerng/viewer?embedded=true&amp;url=https://github.com/SaswatD27/21cs460_group01/raw/main/CS460_Team_01_Midway_Presentation.pdf" width="500" height="375"></embed></p>
</div>
</div>
</div>
</div>
</div>
<div>
<div>
<div>
<div>
<div><hr /></div>
</div>
</div>
</div>
</div>
<div>
<div>
<div>
<div>
<div>&nbsp;</div>
</div>
</div>
</div>
</div>
<div>
<div>
<div>
<div>
<div><hr />
<h3>3. Final Project Presentation/Extension of Baselines</h3>
<p>&nbsp;</p>
</div>
</div>
</div>
</div>
</div>
<div>
<div>
<div>
<ul>Since the midway, we did a number of things, the most notable of which are as follows.
<li>
<p>Created a federated learning code framework from scratch to transfer our work from one that employs local learning via linear regression on a randomly generated dataset to one that employs DNNs (implemented on Tensorflow) to classify digits in MNIST (randomly shuffled and distributed across clients).</p>
</li>
<li>
<p>Tried out various approaches and tweaks to some existing paradigms/models.</p>
</li>
<li>
<p>Designed "<strong>Adaptive Sampling</strong>" an improvement to Dynamic Sampling, with penalisation of the sampling decay coefficient for increase in errors.</p>
</li>
<li>
<p>Designed a <strong>fully decentralised P2P approach</strong> to FL (in contrast to the recent P2P models proposed that involve a level of temporary centralisation).</p>
</li>
<li>
<p>Designed an approach involving <strong>clustering (of clients) in silos</strong> and simultaneously training a <em>silo-specific model</em> and a <em>general model</em> via FL.</p>
</li>
</ul>
</div>
</div>
</div>
<div>
<div>
<div>
<p>&nbsp;</p>
</div>
</div>
</div>
<div>
<div>
<div>
<h4>Specifications of our new framework</h4>
</div>
</div>
</div>
<div>
<div>
<div>
<p><strong>Dataset:</strong></p>
</div>
</div>
</div>
<div>
<div>
<div>
<dl>
<dd>
<p><strong>MNIST</strong> (training data shuffled and distributed unequally at random among 100 clients)</p>
</dd>
<dt><strong>Local Training:</strong></dt>
<dd>
<p>Via a <strong>DNN</strong>, defined and compiled with Tensorflow.</p>
<ul>
<li>
<p><strong>Input Layer</strong>: Flatten Layer.</p>
</li>
<li>
<p><strong>Hidden Layers</strong>: 32 units and 512 units* (later ditched for speed) with ReLU activation.</p>
</li>
<li>
<p><strong>Dropout Layer*</strong> (rate = 0.2): Before the  \(2^\text{nd}\)  Hidden Layer (later ditched)</p>
</li>
<li>
<p><strong>Output Layer:</strong> 10 units with Softmax activation.</p>
</li>
<li>
<p><strong>Batch Normalisation:</strong> Before every hidden and output layer</p>
</li>
</ul>
</dd>
</dl>
</div>
</div>
</div>
<div>
<div>
<div>
<p>In a nutshell, due to time and computing power constraints, we ended up using a DNN with a flatten layer, a hidden layer with 32 units with ReLU activation, followed by an output layer with 10 units with softmax activation, not to mention the batch normalisation layers before the hidden and output layer. As we shall soon see, we found that this was sufficient to give a high degree of accuracy on MNIST.</p>
</div>
</div>
</div>
<div>
<div>
<div>
<dl>
<dt>Federated Averaging was implemented similarly as for our older framework, as per the original paper on Federated Averaging by McMahan et al.</dt>
</dl>
</div>
</div>
</div>
<div>
<div>
<div>
<p>A salient feature of our framework is that it is flexible enough to be used for any Tensorflow based neural network (at least ones that are created using keras.sequential) and for any dataset that is fed into such an NN.</p>
</div>
</div>
</div>
<div>
<div>
<div>
<h4>Baselines</h4>
</div>
</div>
</div>
<div>
<p><strong>N.B.</strong> For testing, we initialised the same server model (i.e. we started training with a weight vector that was common for every run, for example, a weight vector with all 0s for each "coordinate" in the vector) for each run of each model, for a fair comparison.</p>
</div>
<div>
<p>Given the conception of the new code framework with the DNN on MNIST, we re-ran some of the relevant baselines using it, and we got the following results. Please note that the provided figures/graphs are representative, as in they are just a few from the many runs of each model/algorithm.</p>
</div>
<div>
<p><strong>Centralised Learning</strong><br />Which simply is training the DNN using all of the MNIST training data in one place, and precisely what any federated learning algorithm should aspire to match, or at least approach, in terms of accuracy.<br /><strong>Test Accuracy:</strong> 96.52% (Pretty nice!)</p>
</div>
<div>
<p><img src="https://github.com/SaswatD27/21cs460_group01/raw/main/images/MNIST%20Central%201.png" alt="image" /></p>
</div>
<div>
<p><strong>Vanilla FedAveraging</strong></p>
</div>
<div>
<p>Which, as mentioned earlier, is simply an implementation of McMahan et al's model with aggregation via FederatedAvg. Note that here in each round of communication, a fixed proportion of the total number of clients are asked for local updates, which in the language of client sampling is called static sampling.<br /><strong>Number of Communication Rounds:</strong> 50<br /><strong>Test Accuracy:</strong> 94.21% (Not bad at all!)</p>
</div>
<div>
<p><img src="https://github.com/SaswatD27/21cs460_group01/raw/main/images/MNIST%2050%20FedAvg.png" alt="image" /></p>
</div>
<div>
<p><strong>FedAveraging with Dynamic Sampling</strong></p>
</div>
<div>
<p>For a proper recaptitulation of what Dynamic Sampling does, refer to our prior discussion regarding Ji et al in the Midway section. But in a nutshell, what it does is reduce the number of clients sampled per round w.r.t. a decay coefficient  \(\beta\)  and the initial client sampling rate (i.e. by multiplying  \(\frac 1{\exp(-\beta t)}\)  to the initial sampling rate).</p>
</div>
<div>
<p><strong>Decay Coeff.  \(\beta\) :</strong> 0.05<br /><strong>Initial Sampling Rate :</strong> 0.25<br /><strong>Test Accuracy:</strong> 93.7%<br /><strong>Number of Rounds:</strong> 50</p>
</div>
<div>
<div>
<div>
<p><img src="https://github.com/SaswatD27/21cs460_group01/raw/main/images/MNIST%20Dyn%201%2020.png" alt="image" /></p>
</div>
</div>
</div>
<div>
<div>
<div>
<p>Note that dynamic sampling decreases the number of clients per round independent of the change of accuracy per round.</p>
<p><br />The problem? This can slow down convergence and error rectification, or even occasionally and briefly lead to consecutive increases in error because aggregation of several client weights leads to a good aggregate weights estimate, but instead, the number of clients is continually decreasing here with the naive approach that decreasing the number of clients per round would decrease the volume of communication. Okay, that is true, but especially in a short term manner. In the long term, slow error rectification will lead to the model requiring a larger number of rounds of communication, which incurs both a time cost and communication cost in that way. But we can see that the thinking behind this paradigm is not without merit, we got a really good accuracy for substantially less clients' involvement vis-a-vis the vanilla case. But can we couple the reduction of the number of clients with faster convergence in a way that we are fine having the initial decay coefficient (which is positively correlated to how fast the decay occurs) as long as the error does not increase beyond a previously attained error value, at which point we would want to slow down the decay and make sure to involve more clients than in the last round to mitigate the amount of error and bring the amount of accuracy eventually to the highest previously attained accuracy beyond which it fell off. This is precisely the motivation behind us introducing <strong>adaptive sampling</strong>.</p>
</div>
</div>
</div>
<div>
<div>
<div>
<p>More clients involved \(\implies\) Better averaging \(\implies\) Less error.</p>
</div>
</div>
</div>
<div>
<div>
<div>
<h3>I. Adaptive Sampling</h3>
That is, we keep successively penalising the decay coefficient for any fall in accuracy, while retaining the previous index, so as to increase the number of clients for the next round and slow the decay in the sampling rate down, and restore the decay coefficient when accuracy reaches the previous high.</div>
</div>
</div>
<div>
<div>
<div>
<p>The pseudocode for adaptive sampling is as follows.</p>
</div>
</div>
</div>
<div>
<div>
<div>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="https://github.com/SaswatD27/21cs460_group01/raw/main/images/Adaptive%20Sampling%20Algo.jpg" alt="image" width="540" height="628" /></p>
</div>
</div>
</div>
<div>
<div>
<div>
<p>&nbsp;</p>
</div>
</div>
</div>
<div>
<div>
<div>
<p><strong>Note :</strong>  \(n_i\)  is the number of datapoints possessed by the client corresponding to  \(\Omega_t^i\) , and  \(n\)  is the total of all  \(n_i\) &rsquo;s for each  \(\Omega_t^i\in L\) .</p>
</div>
</div>
</div>
<div>
<div>
<div>
<p>Also, note that  \((\gamma)\) is just a parameter we introduced in case we needed to tune the penalisation of the decay coefficient, and we kept it equal to 1 to start off with, and as it turned out, that worked just fine, so we kept it at 1. </p>
</div>
</div>
</div>
<div>
<div>
<div>
<p>We again ran several rounds of experiments for adaptive sampling and some representative results, with similar parameters as for the previous representative run for dynamic sampling, are as follows:</p>
</div>
</div>
</div>
<div>
<div>
<div>
<p><strong>Initial Decay Coeff.  \(\beta\) :</strong> 0.05<br /><strong>Initial Sampling Rate :</strong> 0.25<br /><strong>Gamma  \((\gamma)\)  :</strong> 1<br /><strong>Test Accuracy:</strong> 94.16%<br /><strong>Rounds of Communication:</strong> 20</p>
</div>
</div>
</div>
<div>
<div>
<div>
<p>(It would have risen as accuracy fell in the last step; it had an accuracy of 94.59% after round 19, but since we only specified 20 rounds of communication, it stalled at that.)</p>
</div>
</div>
</div>
<div>
<div>
<div>
<p><img style="float: left;" src="https://github.com/SaswatD27/21cs460_group01/raw/main/images/MNIST%20Adap%201%2020.png" /></p>
</div>
</div>
</div>
<div>
<div>
<div>
<p>&nbsp;</p>
</div>
</div>
</div>
<div>
<div>
<div>
<p>&nbsp;</p>
</div>
</div>
</div>
<div>
<div>
<div>
<p>&nbsp;</p>
</div>
</div>
</div>
<div>
<div>
<div>
<p>&nbsp;</p>
</div>
</div>
</div>
<div>
<div>
<div>
<p>&nbsp;</p>
</div>
</div>
</div>
<div>
<div>
<div>
<p>&nbsp;</p>
</div>
</div>
</div>
<div>
<div>
<div>
<p>&nbsp;</p>
</div>
</div>
</div>
<div>
<div>
<div>
<p>&nbsp;</p>
</div>
</div>
</div>
<div>
<div>
<div>
<p>&nbsp;</p>
</div>
</div>
</div>
<div>
<div>
<div>
<p>What immediately jumps out at us upon viewing this graph is that 1. it seems to lead to smoother convergence, sans any of the jaggedness as for dynamic sampling; and 2. it leads to convergence within lesser rounds of communication, albeit with marginally more clients per round on average being involved than dynamic sampling (owing to the penalisation of the decay coefficient at times along with stalling of the counter variable whenever accuracy drops), and knowing/assuming that the server calls on clients for communication round wise and clients in each round upload their local weights nearly simultaneously, lesser number of rounds implies lesser time taken for this entire exercise of federated learning.</p>
</div>
</div>
</div>
<div>
<div>
<div>
<h3 id="fully-decentralised-p2p-fl-learning" class="unnumbered">II. Fully Decentralised P2P FL Learning:</h3>
</div>
</div>
</div>
<div>
<div>
<div>
<h4 id="motivation" class="unnumbered">Motivation:</h4>
</div>
</div>
</div>
<div>
<div>
<div>
<p>In federated learning, the server aggregates the weight vector of the devices to make a new model, which implies a significant degree of centralisation, which in turn creates a single entity for an adversary to attack or track communications to; alternatively, sending weights to a central server might not be desirable in certain contexts for the sake of privacy.</p>
<p>In addition, traditional federated learning does not address its implementation for P2P networks, which has much potential given the advent of decentralisation to the extent that we see nowadays, and that of smart contracts and decentralised apps (dapps). Naturally, this has been a recent field of inquiry as far as federated learning is concerned.</p>
<p>So, we decided to formulate a model for peer-to-peer learning where local training is done for all the peers involved in a round of training, and then after exchanging local weights among themselves, each device independently performs aggregation via FedAveraging (which in itself is not exactly an expensive task), and can compare the newly aggregated model with their existing ones to see what works best for them, and as a secondary consequence, guard against injection of illicit values by any malicious peer(s) (and we also gave quite some thought on how to nullify/penalise the malicious peer's influence or even remove them entirely in such an event).</p>
</div>
</div>
</div>
<div>
<div>
<div>
<h4 id="baselines-for-p2p-learning" class="unnumbered">Baselines for P2P Learning</h4>
</div>
</div>
</div>
<div>
<div>
<div>
<p>To reiterate, federated learning in the context of P2P networks (i.e. sans a server) is a nascent field of study.</p>
<p><br />Some of the earliest models like BrainTorrent (2019), and that by Behera et al (JPMorgan Chase &amp; Co., 2021) involve taking (i.e. randomly choosing/electing) a temporary "leader" peer node to act in the capacity of the server, thus inducing a level of centralization, and the peers having to accept the leader&rsquo;s aggregation in good faith.</p>
<p><br />Others like FedP2P (2021) involve a model wherein a central server organizes clients into a P2P network after some bootstrapping is done at the server-end, and are not suitable for fully decentralized P2P networks.</p>
<p>Then there are models like IPLS (2021) involve a client acting as a central "leader/server" that assigns tasks to its peers, which resembles task delegation more than imploring devices to work on their own data and their own data only.</p>
<p>All of the serverless models we have come across involve making a peer a "temporary leader/server", and thus have a level of centralization, which brings privacy risks along with it. We aim to remove this aspect to obtain a completely decentralized FL paradigm for P2P networks.</p>
</div>
</div>
</div>
<div>
<div>
<div>
<h4 id="algorithm" class="unnumbered">Description of the Algorithm:</h4>
</div>
</div>
</div>
<div>
<div>
<div>
<ol>
<li>
<p>A dapp or smart contract specifies an initial random model for all the devices in a round of communication/training.</p>
</li>
<li>
<p>A device/peer may send a call for updates to all its peers, periodically or of its own volition.</p>
</li>
<li>
<p>If a good enough proportion of peers agree, then they initialize with a common initial model (specified within the contract initially, else the last shared global model), and train local models. The last 2-3 "accepted" global models for a peer, if any, are stored locally.</p>
</li>
<li>
<p>Each device calls for a number of those locally trained weights from a significant proportion (or all) of its peers and aggregates it.</p>
</li>
<li>
<p>If the model performs better than its existing model, it keeps it (updates the local instance of dapp/smart contract accordingly), else ditches it.</p>
</li>
</ol>
<p>Peers query for how many models ditched the new global model, if a majority do, then initialize the next round of training with the last viable one. (Defends the system against erroneous value injection.)</p>
</div>
</div>
</div>
<div>
<div>
<h4>Experimental Results</h4>
</div>
</div>
<div>
<div>
<p>In our experiments for our P2P federated learning mode, we simulated 100 peers/clients on the aforementioned framework on DNNs/MNIST, with a 0.25 client sampling rate. (Though, practically speaking, all this does is explore the case when 0.25 peers decide to participate in a round of training per round, though perhaps in a real life implementation, it may very well go beyond that, as peers shall seek to maximise the number of them that participate in a given round. 25% of clients chosen at random seemed to be a pretty good conservative estimate to us.)</p>
</div>
</div>
<div>
<div>
<p><strong>Another caveat:</strong> we assume the absence of a malicious peer here, though should one be there, it cannot cause any damage due to each peer choosing the best of the current and the new model, and the only way the adversarial peer can "succeed" is by ensuring that the new model post-aggregation is better than the current model(s) already implemented on the devices, which is not exactly a win for any malicious peer intent on derailing the learning process, and if an aggregated model happens to be way off the rails due to adversarial interference and rejected by a majority of the peers, it shall be rejected entirely and the most recent accepted common aggregated model shall be agreed upon to continue training from the next round onwards. (Note that this shall work especially well on P2P networks with defences against Sybil attacks.)&nbsp;</p>
</div>
</div>
<div>
<div>
<div id="tab:p2p-table" style="text-align: center;">
<table style="margin-left: auto; margin-right: auto;"><caption>Results of Decentralised P2P Fed Learning</caption>
<thead>
<tr class="header">
<th style="text-align: left;">&nbsp;</th>
<th style="text-align: left;">Accuracy of Shared Global Model</th>
<th style="text-align: left;">Max Accuracy in Sample</th>
<th style="text-align: center;">Min Accuracy in Sample</th>
<th style="text-align: left;">Mean Accuracy in Sample</th>
</tr>
</thead>
<tbody>
<tr class="odd" style="text-align: center;">
<td style="text-align: left;">Round 1 (Initial)</td>
<td>93.79%</td>
<td>93.84%</td>
<td>92.67%</td>
<td>93.49%</td>
</tr>
<tr class="even" style="text-align: center;">
<td style="text-align: left;">Round 2</td>
<td>94.25%</td>
<td>94.31%</td>
<td>92.77%</td>
<td>94.02%</td>
</tr>
<tr class="odd" style="text-align: center;">
<td style="text-align: left;">Round 3</td>
<td>94.75%</td>
<td>94.82%</td>
<td>93.97%</td>
<td>94.48%</td>
</tr>
<tr class="even" style="text-align: center;">
<td style="text-align: left;">Round 4</td>
<td>94.71%</td>
<td>94.99%</td>
<td>93.80%</td>
<td>94.62%</td>
</tr>
<tr class="odd" style="text-align: center;">
<td style="text-align: left;">Round 5</td>
<td>94.87%</td>
<td>94.98%</td>
<td>94.38%</td>
<td>94.76%</td>
</tr>
<tr class="even" style="text-align: center;">
<td style="text-align: left;">Round 6</td>
<td>94.97%</td>
<td>95.09%</td>
<td>94.25%</td>
<td>94.85%</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Round 7</td>
<td style="text-align: center;">94.92%</td>
<td style="text-align: center;">95.14%</td>
<td style="text-align: center;">93.80%</td>
<td style="text-align: center;">94.90%</td>
</tr>
</tbody>
</table>
<p style="text-align: left;">And here's a supporting graph to better visualise these values. Note that the max, min and mean accuracies in the sample refer to those within the subcollection of peers that have participated in a given round. Of interest are the trends of shared global model accuracy (which approaches the baseline vanilla FedAvg accuracy) and the mean cluster/sample accuracy.</p>
<p style="text-align: left;"><img style="display: block; margin-left: auto; margin-right: auto;" src="https://github.com/SaswatD27/21cs460_group01/raw/main/images/P2P%20MNIST%202%20Growth.png" />So what do we see here? That there seems to be an overall upward trend across the board for all these different statistics, which seems to perfectly suit the end goal of training using federated learning without a server. Also, we can see that even if a peer had not participated in training for a few rounds when it does go for training, it attains accuracy comparable to its other peers in the sample with accuracy (most probably) higher than that for the preceding rounds. (This is not very surprising of course, but it is a desirable property to possess.)</p>
<h4 style="text-align: left;">Some Concerns</h4>
<ul>
<li style="text-align: left;">
<p>A large proportion of peers must ideally agree for a round of communication, and there might be rounds wherein not a lot of peers would agree. Form of round scheduling might help in this regard, perhaps.</p>
</li>
<li style="text-align: left;">
<p>Outliers may cause problems. (This is true for vanilla FedAvg anyway, so is not an exclusive concern to this model.)</p>
</li>
<li style="text-align: left;">
<p>Inter-peer bandwidth could be a bottleneck in P2P networks, so we would do well to reduce communication size somehow (and as mentioned earlier, this can be achieved by the use of a number of well known communication overhead reducing techniques).</p>
</li>
<li>
<p style="text-align: left;">What about a malicious peer reporting incorrect weights? That&rsquo;s solved; inaccurate models thus aggregated are rejected by peers, as emphasised earlier. Ideally, one would also want to find a way to either isolate, reduce the influence of or entirely remove the malicious peer. (viz. by a multiplicative weights approach, a peer could reduce a weight corresponding to a peer's reputation whenever it ends up with a less accurate model than the one it already has, and as a result, either decrease the weight accorded to the weight vectors of peers in the subcollection of peers in that communication round or call these peers less often; this is an open line of inquiry at the moment.)</p>
</li>
</ul>
<h4 style="text-align: left;">Serving Suggestions (a.k.a. Possible Augmentations to consider while implementing practically)</h4>
<ul>
<li>
<p style="text-align: left;">For the security of communication, we can use something like hybrid encryption to encrypt weight vectors in transit (to protect against eavesdropping adversaries, including non-peers).</p>
</li>
<li>
<p style="text-align: left;">For increasing privacy, differentially private noise can be added.</p>
</li>
</ul>
<h3 style="text-align: left;">III. Subclustering of Clients w.r.t. their Local Updates and Creation of Specific Models for Minority Clusters</h3>
<p style="text-align: left;">In general FL techniques create a common model useful for the majority of devices, suffices for most purposes, but in this process, any minor clusters of devices having different data (and ergo producing different weight vectors post local training) than most may benefit from getting more specific models appropriate for their data in certain contexts.</p>
<p style="text-align: left;"><strong>Algorithm:</strong></p>
<ul>
<li style="text-align: left;">
<p>We start with a regular FL (viz. Vanilla FedAvg) approach to training an FL model.</p>
</li>
<li style="text-align: left;">
<p>Local models of all the devices are clustered (using DB-SCAN) based on their weight vectors.</p>
</li>
<li style="text-align: left;">
<p>All the devices having the same cluster-id are extracted, and federated averaging is done only for those devices (in a P2P manner). This process is repeated until a model is formed for every cluster.</p>
</li>
<li>
<p style="text-align: left;">These weights are returned to the server to provide a model for devices having a different and smaller class of dataset. Devices may opt to use the general model or the specific model, if any.</p>
</li>
</ul>
<h4 style="text-align: left;">Note about Baselines and an Augmentation we Made</h4>
<p style="text-align: left;">Some background on our (admittedly unorthodox) method of creating this model: one of us had actually conceived this while brainstorming all that we could get up to whilst cooking up and testing new models, and we implemented it to see whether it runs properly on simulated data (created in a way so that there are indeed minority classes devices that have similar data but are different in comparison to most other devices). Post that, we proceeded to look at models that might have a similar approach.</p>
<p style="text-align: left;">Most baseline algorithms that we saw during our literature review suggested that most of the work that resembled this vein of thought was implemented by clustering devices based on their data itself in some fashion. We on the other hand chose to cluster devices based on the similarity between the local weights produced after local training during each round. (An honourable mention of such a baseline approach that the instructor pointed out would be FLaPS by Paul et al which one of the authors had gone through in the past but did not recall when the other author actually came up with this approach.)</p>
<p style="text-align: left;">Unfortunately, at a much later stage, it seemed that there was indeed a similar work (with respect to an older version of our model) done by researchers at KTH, Sweden, with minor differences from our initial model.</p>
<p style="text-align: left;">So we went ahead and explored adding a P2P component to intra-silo (i.e. within each minority class/cluster) training of specific models, which would endow an additional benefit in terms of each silo getting to keep their weights private; now this would not matter when the server is aware of the clustering pattern as it can easily compute the specific models, but let's say that a group of clients (say they belong to the same organisation/lab) opt to define (among themselves only, assuming they are all connected as peers) a cluster of their own, regardless of the cluster they have been accorded in that round, then given that the server is not made aware of that custom-defined silo/cluster, the specific model would stay private to the members of the cluster.</p>
<p style="text-align: left;">In short, this augmentation allows clients flexibility to define their own clusters, even if that mightt not give them optimal accuracy.</p>
<h4 style="text-align: left;">Experimental Results (with P2P Intra Silo Learning Implemented)</h4>
<p style="text-align: left;"><strong>Total number of devices:</strong>&nbsp;125</p>
<p style="text-align: left;"><strong>Number of federated learning rounds(T):</strong>&nbsp;10<br /><br /><strong>Client Sampling Rate (per round):</strong> 0.25<br /><br /></p>
</div>
<div id="tab:subclustering">
<table style="margin-left: auto; margin-right: auto;"><caption>Results of Subclustered FL</caption>
<thead>
<tr class="header">
<th style="text-align: left;">&nbsp;</th>
<th style="text-align: left;">&nbsp;</th>
<th style="text-align: center;" colspan="2">Average Testing Error</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">&nbsp;</td>
<td style="text-align: center;">No. of Devices</td>
<td style="text-align: center;">For Global Model</td>
<td style="text-align: center;">For Cluster Specific Models</td>
</tr>
<tr class="even">
<td style="text-align: left;">Majority Cluster</td>
<td style="text-align: center;">110</td>
<td style="text-align: center;"> \(\approx\)0.00203 </td>
<td style="text-align: center;"> \(\approx\)  6.71926 \(\times 10^{-15}\) </td>
</tr>
<tr class="odd">
<td style="text-align: left;">Minority Cluster 1</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;"> \(\approx\)0.15474 </td>
<td style="text-align: center;"> \(\approx\)  6.30220 \(\times 10^{-13}\) </td>
</tr>
<tr class="even">
<td style="text-align: left;">Minority Cluster 2</td>
<td style="text-align: center;">7</td>
<td style="text-align: center;"> \(\approx\)0.12130 </td>
<td style="text-align: center;"> \(\approx\)  6.59985 \(\times 10^{-16}\) </td>
</tr>
</tbody>
</table>
<p>This goes on to show that for non-IID data or situations with clients that have different data could do well to utilise subclustering like this to obtain well-performing specific models.&nbsp;</p>
<p style="text-align: left;">We have only conducted testing for the clusters obtained via DB SCAN on the weight vectors using the older framework (as we ran into time constraints and issues involving implementing DB SCAN on the (even flattened) weights of NNs produced using Keras.</p>
<p style="text-align: left;">Note that we focused more on simulating these clusters in essence in that older framework, and the code would look more general in real-life use cases (in fact the not-successful code on the DNN/MNIST framework should be general in the abovementioned sense and closer to possible real-life implementations of this.)</p>
<p style="text-align: left;">(Accuracy on custom-defined clusters has not been tested for given time constraints and that it is an option to be opted for at the clients' discretion and risk. Though given the errors on the global model be, one can expect errors to that tune or even less.)</p>
</div>
<h4>Possible Future Improvement(s)</h4>
<ul>
<li>
<p>What about we store minority class models and use them as initial models for forks for the respective silos (given a minimum cluster size)? Will it be beneficial? Or will it lead to the splintering off of clients into a multitude of clusters and the overall model(s) catastrophically? We leave it as an open problem.</p>
</li>
</ul>
<div><hr /></div>
<strong>Code Links (for the Final Presentation's Material/Models):</strong>
<ul>
<li><a href="https://github.com/SaswatD27/21cs460_group01/blob/main/Code/CS460_FL_1_02_Functional.ipynb">Adaptive Sampling (MNIST/DNN) with Baselines</a></li>
<li><a href="https://github.com/SaswatD27/21cs460_group01/blob/main/Code/P2PModelMNIST.ipynb">P2P Model (MNIST/DNN)</a></li>
<li><a href="https://github.com/SaswatD27/21cs460_group01/blob/main/Code/Subclustering_P2P_OldFramework.ipynb">Subclustering Model (Old Framework) (Works)</a></li>
<li><a href="https://github.com/SaswatD27/21cs460_group01/blob/main/Code/Subclustering_MNIST(Not%20Working%20Yet).ipynb">Subclustering Model (MNIST/DNN) (More General but Doesn't Work)</a></li>
</ul>
<div><hr /></div>
<h4>Final Presentation Slides</h4>
(Kindly Exclude The Title and Bibliography Slides from the Slide Count)</div>
</div>
<div>
<p><embed style="background-image: url('img/object.gif'); display: block; margin-left: auto; margin-right: auto;" src="https://drive.google.com/viewerng/viewer?embedded=true&amp;url=https://github.com/SaswatD27/21cs460_group01/raw/main/CS460_Team_01_Final_Presentation.pdf" width="500" height="375"></embed></p>
</div>
<div>
<div><hr /></div>
</div>
<div>
<p>We would like to take a moment to express our gratitude to Dr. Subhankar Mishra, not to gain any additional brownie points but to give credit where it is due, for urging us to consider working on federated learning for this project in the first place, which made all of this possible, and for his encouragement and guidance in this respect.</p>
</div>
<div>
<p>And also to the copious amounts of caffeine that fueled this project.</p>
</div>
<div class="page-foot">
  <div class="copyright">
  </div>
</div>
</div>
<script src="https://combinatronics.com/SaswatD27/21cs460_group01/main/katex/katex.min.js"></script>
<script src="https://combinatronics.com/SaswatD27/21cs460_group01/main/katex/auto-render.min.js"></script>
<script>renderMathInElement(document.body)</script>
</html>
